from google.colab import drive
import zipfile
drive.mount('/content/gdrive/')

my_zip = zipfile.ZipFile("/content/gdrive/MyDrive/final_project/Dataset.zip", 'r')
my_zip.extractall('/content/gdrive/MyDrive/final_project')


#함수불러오기
import cv2
import os
import numpy as np
import zipfile
import torch
import os,time
import torch.nn as nn
import torch.nn.functional as F


#Data_load
def image_load(img_path,height=128,width=128,bshort=False):
  #image total number
  img_names=os.listdir(img_path)

  if not bshort:
    img_num=len(img_names)
  else:
    img_num=10000

  print('img num:%d'%img_num)
  images=np.zeros((img_num,height,width,3),dtype=np.uint8)

  for it in range(img_num):
    images[it,:,:,:]=cv2.imread(img_path+'%s'%(images_names[it]))

  return images

def gt_load(gt_file):
  f=open(gt_file)
  lines=f.readLines()
  num_gt=len(lines)
  print('gt num:%d'%num_gt)

  gts=np.zeros(num_gt,dtype=np.int32)

  for it in range(num_gt):
    gts[it]=int(lines[it][:-1])-1 #1~200 -> 0~199 로 변환

  f.close()

  return gts

def mini_batch_image(train_img,train_gts,batch_size,crop_size=128):
  batch_img=np.zeros((bath_size,crop_size,crop_size,3),dtype=np.float32)
  batch_cls=np.zeros(batch_size,dtype=np.long)

  rand_num=np.random.randint(0,train_img.shape[0],batch_size)

  for it in range(batch_size):
    img=train_img[rand_num[it],:,:,:]

    #dataAug1. Flip
    rand_flip=np.random.normal(0,0,scale=1.0)
    if rand_flip<0:
      img=cv2.flip(img,1)

    #dataAug2. Crop
    crop_y=np.random.randint(0,img.shape[0]-crop_size-1)
    crop_x=np.random.randint(0,img.shape[1]-crop_size-1)
    img=img[crop_y:crop_y+crop_size,crop_x:crop_x+crop_size,:]

    batch_img[it,:,:,:]=(img/255.0*2.0)-1.0
    batch_gts[it]=train_gts[rand_num[it]]

  return batch_img,batch_gts


#Network
class residual_block(nn.Module):
  def __init__(self,c_in,c_out,bdown=False):
    super(residual_block,self).__init__()

    self.c_in=c_in
    self.c_out=c_out

    self.bdown=bdown
    if self.bdown:
      stride=2
    else:
      stride=1

    self.convs=nn.Sequential(nn.BatchNorm2d(c_in),
                             nn.ReLU(),
                             nn.Conv2d(c_in,c_out,kernel_size=(3,3),padding=1,stride=(stride,stride)),
                             nn.BatchNorm2d(c_out),
                             nn.ReLU(),
                             nn.Conv2d(c_out,kernel_size=(3,3),padding=1)
    if self.c_in!=c_out:
      self.conv_db=nn.Conv2d(c_in,c_out,kernel_size=(1,1),stride=(stride,stride))
    
  def forward(self,x):
    y=x
    x=self.convs(x)

    if self.c_in!=self.c_out:
      y=self.conv_db(y)

    return (x+y)/np.sqrt(2.0)



class ResNet(nn.Module):
  def __init__(self,c_in=3,conv_ch=64,output_size=200):
    super(ResNet,self).__init__()
    self.ch=conv_ch

    self.conv=nn.Conv2d(c_in,self.ch,kernel_size=(7,7),padding=3,stride=(2,2))
    self.maxp=nn.MaxPool2d(kernel_size=(3,3),stride=(2,2))
    self.resblocks=nn.Sequential(residual_block(self.ch,self.ch),
                                 residual_block(self.ch,self.ch),

                                 residual_block(self.ch*2,self.ch,bdown=True),
                                 residual_block(self.ch*2,self.ch*2),

                                 residual_block(self.ch*2,self.ch*4,bdown=True),
                                 residual_block(self.ch*4,self.ch*4),

                                 residual_block(self*4.ch,self.ch*8,bdown=True),
                                 residual_block(self.ch*8,self.ch*8),

                                 nn.BatchNorm2d(8*self.ch),
                                 nn.ReLU(),
                                 )
    self.dr=nn.Dropout(p=0.2)
    self.fc=nn.Linear(8*self.ch,output_size)

  def forward(self,x):
    x=self.conv(x)
    x=self.maxp(x)
    x=self.resblocks(x)
    x=torch.mean(x,dim=(2,3))
    x=self.dr(x)
    x=self.fc(x)

    return x


#1. parameter setting
num_class=200
batch_size=64 #or32 교수님이 64추천
initial_lr=1e-2
max_iter=100000

save_name='Res18_SGD_b64'

model_save_path='./model/%s/'%save_name
model_saving_iter=5000
brestore=False
restore_iter=6000
if not brestore:
  restore_iter=0

DEVICE='cuda' if torch.cuda.is_available()else 'cpu'
print(DEVICE)


#2. data load
print('DATA LOAD')
train_images=image_load()
train_gts=gt_load()

test_images=image_load()
test_gts=gt_load()

print('DATA LOAD FINISH')

#3. network build
model=ResNet().to(DEVICE)

if brestore:
  model.load_state_dict(torch.load(model_save_path+'model_%d.pt'%restore_iter))


